<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>36-315 Lecture 15</title>
    <meta charset="utf-8" />
    <meta name="author" content="Professor Ron Yurko" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# 36-315 Lecture 15
]
.subtitle[
## Visualizing Distances for High-Dimensional Data
]
.author[
### Professor Ron Yurko
]
.date[
### 3/20/2023
]

---









# Conceptual review

Last class: contour plots, heat maps, and diving into high-dimensional data

#### Today: how do we visualize structure of high-dimensional data?

- Example: What if I give you a dataset with 50 variables, and ask you to make __one visualization__ that best represents the data? _What do you do?_

--

- Do NOT panic and make `\(\binom{50}{2} = 1225\)` pairs of plots!

- __Intuition__: Take high-dimensional data and __represent it in 2-3 dimensions__, then visualize those dimensions


---

## What about high-dimensional data?

Consider this [dataset]((https://github.com/rfordatascience/tidytuesday/blob/master/data/2021/2021-12-21/readme.md) containing nutritional information about Starbucks drinks:


```r
starbucks &lt;- 
  read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-12-21/starbucks.csv") %&gt;%
  # Convert columns to numeric that were saved as character
  mutate(trans_fat_g = as.numeric(trans_fat_g), fiber_g = as.numeric(fiber_g))
starbucks %&gt;% slice(1)
```

```
## # A tibble: 1 × 15
##   product_name size   milk  whip serv_…¹ calor…² total…³ satur…⁴ trans…⁵ chole…⁶
##   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1 brewed coff… short     0     0     236       3     0.1       0       0       0
## # … with 5 more variables: sodium_mg &lt;dbl&gt;, total_carbs_g &lt;dbl&gt;, fiber_g &lt;dbl&gt;,
## #   sugar_g &lt;dbl&gt;, caffeine_mg &lt;dbl&gt;, and abbreviated variable names
## #   ¹​serv_size_m_l, ²​calories, ³​total_fat_g, ⁴​saturated_fat_g, ⁵​trans_fat_g,
## #   ⁶​cholesterol_mg
```


#### Visualize structure among observations using distances matrices

---

## Thinking about distance...

When describing visuals, we've implicitly "clustered" observations together

- e.g., where are the mode(s) in the data?

--

These types of task require characterizing the __distance__ between observations

- Clusters: groups of observations that are "close" together

--

This is easy to do for 2 quantitative variables: just make a scatterplot (possibly with contours or heatmap)

#### But how do we define "distance" for high-dimensional data?

--

Let `\(\boldsymbol{x}_i = (x_{i1}, \dots, x_{ip})\)` be a vector of `\(p\)` features for observation `\(i\)`

Question of interest: How "far away" is `\(\boldsymbol{x}_i\)` from `\(\boldsymbol{x}_j\)`?

--

When looking at a scatterplot, you're using __Euclidean distance__ (length of the line in `\(p\)`-dimensional space):

`$$d(\boldsymbol{x}_i, \boldsymbol{x}_j) = \sqrt{(x_{i1} - x_{j1})^2 + \dots + (x_{ip} - x_{jp})^2}$$`

---

## Distances in general

There's a variety of different types of distance metrics: [Manhattan](https://en.wikipedia.org/wiki/Taxicab_geometry), [Mahalanobis](https://en.wikipedia.org/wiki/Mahalanobis_distance), [Cosine](https://en.wikipedia.org/wiki/Cosine_similarity), [Kullback-Leiber Divergence](https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence), [Wasserstein](https://en.wikipedia.org/wiki/Wasserstein_metric), but we're just going to focus on [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance)

--

`\(d(\boldsymbol{x}_i, \boldsymbol{x}_j)\)` measures pairwise distance between two observations `\(i,j\)` and has the following properties:

1. __Identity__: `\(\boldsymbol{x}_i = \boldsymbol{x}_j \iff d(\boldsymbol{x}_i, \boldsymbol{x}_j) = 0\)`

2. __Non-Negativity__: `\(d(\boldsymbol{x}_i, \boldsymbol{x}_j) \geq 0\)`

3. __Symmetry__: `\(d(\boldsymbol{x}_i, \boldsymbol{x}_j) = d(\boldsymbol{x}_j, \boldsymbol{x}_i)\)`

4. __Triange Inequality__: `\(d(\boldsymbol{x}_i, \boldsymbol{x}_j) \leq d(\boldsymbol{x}_i, \boldsymbol{x}_k) + d(\boldsymbol{x}_k, \boldsymbol{x}_j)\)`

--

.pull-left[

__Distance Matrix__: matrix `\(D\)` of all pairwise distances

- `\(D_{ij} = d(\boldsymbol{x}_i, \boldsymbol{x}_j)\)`

- where `\(D_{ii} = 0\)` and `\(D_{ij} = D_{ji}\)`

]
.pull-right[

`$$D = \begin{pmatrix}
                0 &amp; D_{12} &amp; \cdots &amp; D_{1n} \\
                D_{21} &amp; 0 &amp; \cdots &amp; D_{2n} \\
                \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
                D_{n1} &amp; \cdots &amp; \cdots &amp; 0
            \end{pmatrix}$$`

]

---

## What could go wrong with Euclidean distance?

---

## Multi-dimensional scaling (MDS)

#### General approach for visualizing distance matrices

- Puts `\(n\)` observations in a `\(k\)`-dimensional space such that the distances are preserved as much as possible

  - where `\(k &lt;&lt; p\)` typically choose `\(k = 2\)`
  
--

MDS attempts to create new point `\(\boldsymbol{y}_i = (y_{i1}, y_{i2})\)` for each unit such that:

`$$\sqrt{(y_{i1} - y_{j1})^2 + (y_{i2} - y_{j2})^2} \approx D_{ij}$$`

- i.e., distance in 2D MDS world is approximately equal to the actual distance

--

#### Then plot the new `\(\boldsymbol{y}\)`s on a scatterplot

- Use the `scale()` function to ensure variables are comparable

- Make a distance matrix for this dataset

- Visualize it with MDS

---

## MDS workflow example with Starbucks drinks

.pull-left[


```r
starbucks_scaled_quant_data &lt;- starbucks %&gt;%
  dplyr::select(serv_size_m_l:caffeine_mg) %&gt;%
  scale(center = FALSE, 
*       scale = apply(., 2, sd, na.rm = TRUE))

*dist_euc &lt;- dist(starbucks_scaled_quant_data)

*starbucks_mds &lt;- cmdscale(d = dist_euc, k = 2)

starbucks &lt;- starbucks %&gt;%
  mutate(mds1 = starbucks_mds[,1],
         mds2 = starbucks_mds[,2])

starbucks %&gt;%
  ggplot(aes(x = mds1, y = mds2)) +
  geom_point(alpha = 0.5) +
  labs(x = "Coordinate 1", y = "Coordinate 2")
```

]

.pull-right[

&lt;img src="figs/Lec15/unnamed-chunk-3-1.png" width="100%" /&gt;

]

---

## What does `dist()` return?


```r
*dist(starbucks_scaled_quant_data[1:8,])
```

```
##           1         2         3         4         5         6         7
## 2 1.0597905                                                            
## 3 2.1605009 1.1015883                                                  
## 4 3.3885615 2.3316426 1.2323454                                        
## 5 1.4722992 2.3802999 3.4258192 4.6439965                              
## 6 1.5671249 2.2148502 3.1494033 4.3218904 0.6904406                    
## 7 1.9247890 2.2591636 3.0086115 4.0906365 1.3835219 0.6941308          
## 8 2.4275777 2.4999068 3.0232984 3.9688066 2.0714599 1.3824217 0.6883099
```


#### Default distance calculation is Euclidean

---

## What does `cmdscale` do?


```r
*starbucks_mds &lt;- cmdscale(d = dist_euc, k = 2)
```


`cmdscale()` is the function we use to run MDS and it has two inputs: 

1. `d`: distance matrix, e.g., `dist_euc`

2. `k`: number of dimensions we want, e.g., usually 2 for visualization purposes

Input is `\(N \times N\)` matrix, and the output is `\(N \times 2\)`

--

To grab the output, we just grab the two columns of `starbucks_mds` and then can
make a scatterplot of these two new dimensions


```r
starbucks &lt;- starbucks %&gt;%
* mutate(mds1 = starbucks_mds[,1],
*        mds2 = starbucks_mds[,2])
```


---

## Interpreting the 2D projection

&lt;img src="figs/Lec15/unnamed-chunk-7-1.png" width="100%" style="display: block; margin: auto;" /&gt;


---

## View structure with additional variables - `size`


&lt;img src="figs/Lec15/unnamed-chunk-8-1.png" width="100%" style="display: block; margin: auto;" /&gt;


---

## View structure with additional variables - `sugar_g`


&lt;img src="figs/Lec15/unnamed-chunk-9-1.png" width="100%" style="display: block; margin: auto;" /&gt;



---

## Main Takeaways

When data is high dimensional, it's impossible to visualize _every_ dimension in the data, so instead:

#### We reduce the data to a small number of dimensions, and then plot those dimensions

1. __Compute a distance matrix__: reduces the data to a single distance between points

2. __Run Multi-Dimensional Scaling (MDS)__: summarizes the distance matrix in 2 or 3 dimensions

3. __Plot the dimensions provided by MDS__

Adding other dimensions (e.g., via color) when plotting MDS can be a great way to see clusters in the data

--

+ __HW5 is due Wednesday March 22nd!__

+ __Graphics critique due April 7th!__

+ Review more code in Lecture 15 Demo! 


#### Next time: Dendrograms to visualize distances and clusters


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
